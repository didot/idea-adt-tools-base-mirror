/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.build.transform.api;

import com.android.annotations.NonNull;
import com.google.common.annotations.Beta;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A Transform that processes build content.
 *
 * It receives the content as {@link TransformInput} objects, and writes the result into one or
 * more {@link TransformOutput}.
 *
 * The Transform also indicates what it applies to (content, scope) and what it generates (content,
 * format).
 *
 * It can also have secondary input and output files. These are handled separately from the content
 * objects.
 */
@Beta
public interface Transform {

    /**
     * How the transform consumes (or not) its input streams.
     */
    enum Type {
        /** Writes the input streams in matching output streams */
        AS_INPUT,
        /** Combines all the input streams into a single output stream */
        COMBINED,
        /** A Transform that only reads the input stream. It does not actually consumes them, and
         * let them available for another transform. */
        NO_OP
    }

    /**
     * Returns the unique name of the transform.
     *
     * This is associated with the type of work that the transform does. It does not have to be
     * unique per variant.
     */
    @NonNull
    String getName();

    /**
     * Returns the type(s) of data that is consumed by the Transform. This may be more than
     * one type.
     */
    @NonNull
    Set<ScopedContent.ContentType> getInputTypes();

    /**
     * Returns the type(s) of data that is generated by the Transform. This may be more than
     * on type.
     */
    @NonNull
    Set<ScopedContent.ContentType> getOutputTypes();

    /**
     * Returns the scope(s) of the Transform. This indicates what the transform consumes, not in
     * term of content types, but in term of which streams it consumes.
     */
    @NonNull
    Set<ScopedContent.Scope> getScopes();

    /**
     * Returns the referenced scope(s) for the Transform. These scopes are not consumed by
     * the Transform. They are provided as inputs, but are still available as inputs for
     * other Transforms to consume.
     */
    @NonNull
    Set<ScopedContent.Scope> getReferencedScopes();

    /**
     * Returns the type of the Transform.
     *
     * This indicates how the Transform manipulate its inputs to create outputs.
     */
    @NonNull
    Type getTransformType();

    /**
     * Returns the format of the output stream(s) that this Transform writes into.
     */
    @NonNull
    ScopedContent.Format getOutputFormat();

    /**
     * Returns a list of additional file(s) that this Transform needs to run.
     *
     * Changes to files returned in this list will trigger a new execution of the Transform
     * even if the streams haven't been touched.
     * Any changes to these files will trigger a non incremental execution.
     */
    @NonNull
    Collection<File> getSecondaryFileInputs();

    /**
     * Returns a list of additional (out of streams) file(s) that this Transform creates.
     *
     * Changes to files returned in this list will trigger a new execution of the Transform
     * even if the streams haven't been touched.
     * Changes to these output files force a non incremental execution.
     */
    @NonNull
    Collection<File> getSecondaryFileOutputs();

    /**
     * Returns a map of non-file input parameters using a unique identifier as the map key.
     *
     * Changes to values returned in this map will trigger a new execution of the Transform
     * even if the streams haven't been touched.
     * Changes to these values force a non incremental execution.
     */
    @NonNull
    Map<String, Object> getParameterInputs();

    /**
     * Returns whether the Transform can perform incremental work.
     *
     * If it does, then the TransformInput will contains a list of changed/removed/added files.
     */
    boolean isIncremental();

    /**
     * Perform the Transform.
     *
     * If the type of the Transform is {@link Type#AS_INPUT}, each inputs has a corresponding
     * {@link TransformOutput}.
     *
     * If the type of the Transform is {@link Type#COMBINED}, then all the {@link TransformOutput}
     * in the map are the same instance.
     *
     * If the type of the Transform is {@link Type#NO_OP}, then all values in the map are
     * <code>null</code>.
     *
     * The Transform can require a non-incremental changes, either because {@link #isIncremental()}
     * returns false, or because there is a change in secondary files
     * (as returned by {@link #getSecondaryFileInputs()}), or a change to non input file parameters
     * (as returned by {@link #getParameterInputs()}), or an output was clobbered by something.
     *
     * If this happens then <var>isIncremental</var> will be false, and
     * {@link TransformInput#getChangedFiles()} will return an empty map. In that case, the
     * transform should look directly at {@link TransformInput#getFiles()} to find the files. This
     * is different from Gradle's behavior where clean builds receive all files in the changed file
     * list.
     *
     * @param inputs the inputs/outputs of the transform
     * @param referencedInputs the referenced-only inputs
     * @param isIncremental whether the transform is incremental.
     * @throws IOException if an IO error occurs
     * @throws InterruptedException
     * @throws TransformException Generic exception encapsulating the cause.
     */
    void transform(
            @NonNull Map<TransformInput, TransformOutput> inputs,
            @NonNull List<TransformInput> referencedInputs,
            boolean isIncremental) throws IOException, TransformException, InterruptedException;
}

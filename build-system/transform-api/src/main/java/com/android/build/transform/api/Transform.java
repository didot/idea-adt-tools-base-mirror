/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.build.transform.api;

import com.android.annotations.NonNull;
import com.google.common.annotations.Beta;

import java.io.File;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

/**
 * A Transform that processes build content.
 *
 * The Transform indicates what it applies to (content, scope) and what it generates (content,
 * format), which is used when the transform is added to the list of tasks through the
 * TransformManager.
 *
 * It receives the content as {@link TransformInput} objects, and writes the result into one or
 * more {@link TransformOutput}. However this base interface does not actually handles
 * inputs/outputs. This is handled by children interfaces.
 *
 * It can also have secondary input and output files. These are handled separately from the content
 * objects.
 */
@Beta
public interface Transform {

    /**
     * How the transform consumes (or not) its input streams.
     */
    enum Type {
        /** Writes the input streams in matching output streams */
        AS_INPUT,
        /** Combines all the input streams into a single output stream */
        COMBINED,
        /** A Transform that only reads the input stream. It does not actually consumes them, and
         * let them available for another transform. */
        NO_OP,
        /** A transform that creates an additional output stream on top of its regular output. */
        FORK_INPUT
    }

    /**
     * Returns the unique name of the transform.
     *
     * This is associated with the type of work that the transform does. It does not have to be
     * unique per variant.
     */
    @NonNull
    String getName();

    /**
     * Returns the type(s) of data that is consumed by the Transform. This may be more than
     * one type.
     */
    @NonNull
    Set<ScopedContent.ContentType> getInputTypes();

    /**
     * Returns the type(s) of data that is generated by the Transform. This may be more than
     * one type.
     */
    @NonNull
    Set<ScopedContent.ContentType> getOutputTypes();

    /**
     * Returns the scope(s) of the Transform. This indicates what the transform consumes, not in
     * term of content types, but in term of which streams it consumes.
     */
    @NonNull
    Set<ScopedContent.Scope> getScopes();

    /**
     * Returns the referenced scope(s) for the Transform. These scopes are not consumed by
     * the Transform. They are provided as inputs, but are still available as inputs for
     * other Transforms to consume.
     */
    @NonNull
    Set<ScopedContent.Scope> getReferencedScopes();

    /**
     * Returns the type of the Transform.
     *
     * This indicates how the Transform manipulate its inputs to create outputs.
     */
    @NonNull
    Type getTransformType();

    /**
     * Returns the format of the output stream(s) that this Transform writes into.
     */
    @NonNull
    ScopedContent.Format getOutputFormat();

    /**
     * Returns a list of additional file(s) that this Transform needs to run.
     *
     * Changes to files returned in this list will trigger a new execution of the Transform
     * even if the streams haven't been touched.
     * Any changes to these files will trigger a non incremental execution.
     */
    @NonNull
    Collection<File> getSecondaryFileInputs();

    /**
     * Returns a list of additional (out of streams) file(s) that this Transform creates.
     *
     * Changes to files returned in this list will trigger a new execution of the Transform
     * even if the streams haven't been touched.
     * Changes to these output files force a non incremental execution.
     */
    @NonNull
    Collection<File> getSecondaryFileOutputs();

    /**
     * Returns a map of non-file input parameters using a unique identifier as the map key.
     *
     * Changes to values returned in this map will trigger a new execution of the Transform
     * even if the streams haven't been touched.
     * Changes to these values force a non incremental execution.
     */
    @NonNull
    Map<String, Object> getParameterInputs();

    /**
     * Returns whether the Transform can perform incremental work.
     *
     * If it does, then the TransformInput will contains a list of changed/removed/added files.
     */
    boolean isIncremental();
}
